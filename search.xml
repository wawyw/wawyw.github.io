<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux C编程实战之线程控制学习记录</title>
      <link href="posts/37062.html"/>
      <url>posts/37062.html</url>
      
        <content type="html"><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><p>线程是计算机中独立运行的最小单位，运行时占用很少的系统资源。在用户看来，多个线程是同时执行，但从操作系统调度来看，各个线程是交替执行。系统不停的在各个线程之间切换，每个线程只有在系统分配给它的时间片内才能取得CPU的控制权，执行线程中的代码。（对于单CPU单核的情况）</p><p>那么为什么在支持多进程的情况下又引入多线程呢？</p><ul><li>节约资源，节约时间。与每个进程都有独立的地址空间不同，同一进程内的线程共享进程的地址空间，故创建新线程花费时间少，线程间的切换速度也比进程快。</li><li>可以提高应用程序的响应速度。</li><li>可以提高多处理器的效率</li><li>可以改善程序的结构</li></ul><p>虽然线程在进程内部共享地址空间，打开的文件描述符等资源，但线程也有其私有的数据信息，包括：</p><ul><li>线程号（thread ID)</li><li>寄存器 [程序计数器,堆栈指针]</li><li>堆栈</li><li>信号掩码</li><li>优先级</li><li>线程的私有存储空间</li></ul><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>线程的创建通过函数 pthread_create 来完成，该函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#incldue<span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_creat</span><span class="params">(<span class="keyword">pthred_t</span> *thread,<span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span> *(*start_routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> arg)</span></span>;</span><br></pre></td></tr></table></figure><p>其作用是：创建线程号为thread，线程属性为attr，执行参数为arg的start_routine函数的线程。</p><p>新创建的线程去运行指针指向的函数,而原线程继续运行。</p><p>创建线程其他系统函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>pthread_t pthread_self(void)</td><td>类似于getpid(),获取线程自身线程ID</td></tr><tr><td>int pthread_equal(pthread_t thread1,pthread_t thread2)</td><td>判断两个进程是否为同一进程</td></tr><tr><td>int pthread_once(pthread_once_t  * once_control,void(*int_routine)(void))</td><td>保证该函数仅执行一次</td></tr></tbody></table><p>下面来看看如何创建进程，如 <code>createThread.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_thid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;                     <span class="comment">//声明进程ID变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent pthread is me,my thid is %lu\n&quot;</span>,pthread_self( ));</span><br><span class="line">    <span class="keyword">if</span>(pthread_create(&amp;thid,<span class="literal">NULL</span>,(<span class="keyword">void</span> *)get_thid,<span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);                 <span class="comment">//调用函数进行进程的创建</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_thid</span><span class="params">(<span class="keyword">void</span>)</span>                      <span class="comment">//创建进程时,被调用的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;</span><br><span class="line"></span><br><span class="line">    thid = pthread_self( );</span><br><span class="line">    <span class="keyword">if</span>(thid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child pthread,my thid is %lu\n&quot;</span>,thid);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://i.loli.net/2021/02/13/27KWHL3YgbxfISF.png" alt="image-20210213172539505"></p><blockquote><p>由于pthread库不是标准linux库， 需在编译命令后面添加 -lpthread </p></blockquote><h1 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h1><p>在Linux环境下,有两种方式实现线程的终止</p><ul><li>调用return函数,实现线程终止</li><li>使用POSIX标准的接口API,pthread_exit函数</li></ul><p>这两个函数主要的区别之处在于在主线程中调用的区别:</p><p>在主线程中调用return/exit,会使主线程结束,进而整个线程结束,全部线程消亡</p><p>如果是调用pthread_exit( )函数,则主线程消亡后,其他线程并不会受到影响,知道所有线程结束,进程才会结束</p><blockquote><p>线程的终止时最重要的问题就是关于资源的释放问题，特别是一些临界资源</p></blockquote><p>临界资源在同一时间只能被其中一个线程所使用,如若被多个线程使用,则会导致资源混乱。而如果临界资源给一个线程所使用,该线程退出时没有释放临界资源，则其他线程会一直认为该临界资源还在被其他线程所占用，就会导致死锁问题的出现。死锁问题的出现,在程序设计的过程中，往往是灾难性的，所以为了妥善处理线程结束时临界资源的释放问题,Linux系统提供了一对函数：pthread_cleanup_push()、pthread_cleanup_pop()用于自动释放资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pthread_cleanup_push(routine ,arg) \</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">pthread_cleanup_buffer</span> <span class="title">buffer</span>;</span> \</span><br><span class="line">          _pthread_cleanup_push(&amp;buffer,(routine),(arg));</span><br><span class="line"><span class="meta">#dedine pthread_cleanup_pop  \</span></span><br><span class="line">         _pthread_clean_pop(&amp;buffer,(exeute));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>线程终止时另外一个要注意的问题是线程间的同步问题</p></blockquote><p>一般情况下,进程中各个线程的运行是相互独立的,线程的终止并不会相互通知,终止的线程资源仍归线程独有。所以资源的同步十分重要,同进程中的wait函数,在线程中所使用的是pthread_join( )函数,其声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthred.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phread_exit</span><span class="params">(<span class="keyword">void</span> *retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thid,<span class="keyword">void</span> *thread_return)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thid)</span></span>;</span><br></pre></td></tr></table></figure><p>函数pthread_join用来使调用者挂起等待thid线程的结束</p><blockquote><p>注意一个线程只能被另一个线程所等待，若被多个线程等待，其中一个线程恢复恢复就绪状态后，其他线程便进入了死锁，并且被等待的线程必须处于可join的状态,即它不能被设定为DETACHED（处于DETACHED状态的线程是指内核不关心线程返回值,线程结束后,内核自动回收的分离模式）所以，为了防止内存泄漏,并且完成线程同步，所有的线程结束时，都要设定为DETACHED或者 pthread_join( )等待</p></blockquote><p>如以下线程终止实例 <code>jointhread.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thid,<span class="literal">NULL</span>,(<span class="keyword">void</span> *)test,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(thid,(<span class="keyword">void</span> *)&amp;status);                                     <span class="comment">//使主线程进行阻塞,等待子线程结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I  (%lu)  have waited for a long time  %d&quot;</span>,pthread_self( ) ,status);        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am for test !\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">20</span>);                                                  <span class="comment">//用sleep来延时函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I have achieved!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="C:\Users\32662\AppData\Roaming\Typora\typora-user-images\image-20210213213237481.png" alt="image-20210213213237481"></p><p>以上结果即可看出,调用函数对目标函数完成了挂起等待。</p><h1 id="私有数据"><a href="#私有数据" class="headerlink" title="私有数据"></a>私有数据</h1><p>区别于之前提到的私有的数据信息，此处私有数据指的是多个线程中操作不同的数据。不同的线程对私有数据的访问对彼此之间是不可见的，操作互不影响，即键同名且全局但访问内存空间不同。</p><p>在这里举一个特殊的的例子：errno全局变量，它返回标准的出错代码。理论上errno应该是任何线程都够访问的全局变量，但是如若errno中保存的值还没有被使用，便被其他线程更改了其中的值，同样也会影响使用。像这种全局变量，即是我们此处要讨论的私有数据，即都能访问的全局变量，但是在各个线程中又是不一样的值。</p><p>私有数据的实现方式借用了：<strong>一键多值</strong>。对这个键可以理解为：一个数据管理器,在各个线程中,调用时,键会被告诉在此线程中应该使用什么值。</p><p>操作线程私有数据的函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_creat</span> <span class="params">(<span class="keyword">pthread_key_t</span> *key,<span class="keyword">void</span> (*destr funcation) (<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span> <span class="params">(<span class="keyword">pthred_key_t</span> *key,<span class="keyword">const</span> <span class="keyword">void</span> *pointer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span> <span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>Creat函数是用来创建键的</li><li>setspecific函数用来将线程的私有数据与键绑定,在线程自身中调用</li><li>getspecific函数用来获取键值中绑定的私有数据</li><li>delete函数用来销毁键</li></ul><blockquote><p>注意：在pthread_key_creat函数中使用了析构函数。所谓析构函数指的是用来在键值使用完成之后</p><p>清除并释放与键值绑定的私有数据所占的内存空间。键值对与私有数据所占用的并不是相同的数据空间，所以要分开进行释放。一旦在键值对释放时，未释放私有数据所占据的空间，则会导致内存泄漏，灾难性的后果。所以调用析构函数有其一定的必要性，当为NULL，会调用内核自身的清理函数。</p><p>一般情况下,线程调用malloc为私有数据分配内存空间</p></blockquote><p>示例 <code>tsd.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> key;                <span class="comment">//定义全局变量库--键</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;          <span class="comment">//线程1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;          <span class="comment">//线程2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;                 <span class="comment">//线程ID</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread begins running!\n&quot;</span>);</span><br><span class="line">    pthread_key_create(&amp;key,<span class="literal">NULL</span>);                        <span class="comment">//参数为键地址,以及析构函数(用于私有数据的内存清理),如果为NULL,则调用系统的清理函数</span></span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);               <span class="comment">//四个参数依次是线程ID,线程属性,调用函数,函数参数</span></span><br><span class="line">    sleep(<span class="number">10</span>);                                            <span class="comment">//睡眠以使主线程等待</span></span><br><span class="line">    pthread_key_delete(key);                              <span class="comment">//销毁键,私有数据的销毁必须在其之前,不然会内存泄漏</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mian pthread ends \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tsd = <span class="number">5</span>;                                          <span class="comment">//pthread中的私有数据</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thid_1;                                     <span class="comment">//分配新的线程号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pthread 1  %lu is running!\n&quot;</span>,pthread_self(  ));</span><br><span class="line">    pthread_setspecific(key,(<span class="keyword">void</span> *)tsd);                        <span class="comment">//使键与私有数据绑定</span></span><br><span class="line">    pthread_create(&amp;thid_1,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);            <span class="comment">//创建新线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread1 %lu ends,pthread&#x27;s tsd is %d\n&quot;</span>,pthread_self(  ),pthread_getspecific(key));</span><br><span class="line">    sleep(<span class="number">5</span>);                                            <span class="comment">//睡眠以等待新线程结束</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tsd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pthread 2 %lu is running\n&quot;</span>,pthread_self(  ));</span><br><span class="line">    pthread_setspecific(key,(<span class="keyword">void</span> *)tsd);                       <span class="comment">//绑定键值与私有数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %lu ends,thread&#x27;s tsd is %d\n&quot;</span>,pthread_self(  ),pthread_getspecific(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="C:\Users\32662\AppData\Roaming\Typora\typora-user-images\image-20210213232526858.png" alt="image-20210213232526858"></p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程最大的特点是资源的共享性，其中的同步问题十分重要。以下是Linux中处理同步问题的常用方式。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁通过锁机制来实现线程间的同步，在同一个时刻它通常只允许一个线程执行一个关键部分的代码。</p><p>1、使用互斥锁前必须先进行初始化操作。初始化有两种方式，一种是静态赋值法，将宏结构常量赋给互斥锁，另外一种方式是通过<code>pthread_mutex_init</code>函数初始化互斥锁。</p><p>2、初始化后就可以给给互斥锁加锁了。加锁有两个函数:<code>pthread_mutex_lock()</code>和<code>pthread_mutex_trylock()</code>。用<code>pthread_mutex_lock()</code>加锁的时候，如果mutex已经被锁住，当前尝试加锁的进程就会阻塞，直到互斥锁被其他线程释放，当<code>pthread_mutex_lock</code>函数返回时，说明互斥锁已经被当前进程成功加锁。<code>pthread_mutex_trylock</code>函数则不同，如果mutex已经被加锁，它将立即返回，返回的错误码为EBUSY，而不是阻塞等待。</p><p>3、用<code>pthread_mutex_unlock</code>函数解锁时，要满足两个条件：一是互斥锁必须处于加锁状态，二是调用本函数的线程必须是给互斥锁加锁的线程。解锁后如果有其他线程在等待互斥锁，等待队列中的第一个将获得互斥锁</p><p>4、当一个互斥锁使用完毕后，必须进行清除，清除互斥锁使用函数<code>pthread_mutex_destroy</code>。<br>清除一个互斥锁意味着释放它所占用的资源。清除锁时要求当前处于开放状态，若锁处于锁定状态，函数放回EBUSY，该函数成功之行时返回0。由于在Linux中，互斥锁并不占用内存，因此<code>pthread_mutex_destroy()</code>除了解除互斥锁的状态外没有其他操作。</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量是利用线程见共享的全局变量进行同步的一种机制。条件变量宏观上类似if语句，符合条件就能执行某段程序，否则只能等待条件成立。</p><p>使用条件变量主要包括两个动作：一个等待使用资源的线程等待”条件变量被设置为真”；另一个线程在使用完资源后”设置条件为真”，这样就可以保证线程间的同步了。这样就存在一个关键问题，这就是要保证条件变量能被正确的修改，条件变量要受到特殊的保护，实际使用中互斥锁扮演者这样一个保护者的角色。Linux也提供了一系列对条件变量操作的函数。</p><p>1、与互斥锁一样，条件变量的初始话也有两种方式，一种是静态赋值法，将宏结构常量PTHREAD_COND_INITIALIZER赋给互斥锁。另一种方式是使用函数<code>pthread_cond_init</code>。</p><p>2、<code>pthread_cond_wait</code>函数释放有mutex指向的互斥锁，同时使当前线程关于cond所指向的条件变量阻塞，直到条件被信号唤醒。通常条件表达式在互斥锁的保护下求值，如果条件表达式为假，那么线程基于条件变量阻塞。当一个线程改变条件变量的同时，条件变量获得一个信号，使得条件变量的线程退出阻塞状态。<br><code>pthread_cond_timedwait</code>函数和<code>pthread_cond_wait</code>函数用法类似，差别在于<code>pthread_cond_timedwait</code>函数将阻塞直到条件变量获得信号或者经过abstime指定的时间，也就是说，如果在给定时刻前条件没有满足，则返回ETIMEOUT，结束等待。</p><p>3、线程被条件变量阻塞后，可以通过函数<code>pthread_cond_signal</code>和<code>pthread_cond_broadcast</code>激活。<br><code>pthread_cond_signal</code>激活一个等待条件成立的线程，存在多个等待线程时，按入队顺序激活其中一个，而<code>pthread_cond_broadcast</code>则激活所有等待线程。</p><p>4、当一个条件变量不再使用时，需要将其清除。清除一个条件变量通过调用<code>pthread_cond_destroy()</code>实现。<code>pthread_cond_destroy</code>函数清除由cond指向的条件变量。注意：只有在没有线程等待该条件变量的时候才能清除这个条件变量，否则返回EBUSY。</p><p>示例代码 <code>condition.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;unistd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hander</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(arg);</span><br><span class="line">    (<span class="keyword">void</span>)pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_cleanup_push(hander, &amp;mutex);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread1 is running\n&quot;</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex); <span class="comment">//条件变量使用时配合互斥锁使用</span></span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread1 applied the condition\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread2 is running\n&quot;</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        pthread_cond_wait(&amp;cond,&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread2 applied the condition\n&quot;</span>);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thid1,thid2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;condition variable study!\n&quot;</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thid1,<span class="literal">NULL</span>,thread1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;thid2,<span class="literal">NULL</span>,thread2,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        pthread_cond_signal(&amp;cond);</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line">    pthread_exit(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步信号"><a href="#异步信号" class="headerlink" title="异步信号"></a>异步信号</h2><p>在Linux系统中，线程是在内核外实现的，它不像进程那样在内核中实现，Linux线程本质上是轻量级的进程。信号可以被进程用来进行相互通信，一个进程通过信号通知另一个进程发生了某件事件，比如该进程所需要的输入数据已经就绪。线程同进程一样也可以接收和处理信号，信号也是一种线程同步的手段。</p><p>信号于任何线程都是异步的，也就是说信号到达线程的时间是不定的。如果有多个线程可以接收异步信号，则只有一个被选中，如果并发的多个同样的信号被送到一个进程，每一个将被不同的线程处理，如果所有的线程都屏蔽该信号，则这些信号将被挂起，直到有信号解除屏蔽来处理它们。其中函数<code>pthread_kill</code>用来向特定的线程发送信号signal，函数<code>pthread_sigmask</code>用来设置线程的信号屏蔽码，但对不允许屏蔽的Cancel信号和不允许相应的Restart信号进行了保护，函数<code>sigwait</code>用来阻塞线程。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux C编程实战之进程控制学习记录</title>
      <link href="posts/54831.html"/>
      <url>posts/54831.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统借助于进程来管理计算机的软、硬件资源，支持多任务的并行执行。而操作系统最核心的概念就是进程。以下对进程相关的学习内容进行简单记录。</p><h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p>进程是操作系统资源管理的最小单位，简单地讲就是运行中的程序。Linux系统可以同时启动多个进程。</p><blockquote><p>进程和程序的区别：</p><p>进程：是动态的，运行中的程序；</p><p>程序：是静态的，一些保存在硬盘上的可执行的代码。</p></blockquote><blockquote><p>进程和线程关系：</p><p>计算机为在同一时间执行更多任务，在进程内部又划分了许多线程。线程是比进程更小的能独立运行的基本单位。一个线程可以创建和撤销另一个线程，同一个进程中可以有多个线程并行执行。</p></blockquote><p>LInux下可通过命令 <code>ps </code> 或 <code>pstree</code> 查看当前系统中的进程。</p><p><img src="https://i.loli.net/2021/02/06/ZmaIterEGfiBgw4.png" alt="image-20210206220107548"></p><p><img src="https://i.loli.net/2021/02/06/Kkrx4EoPNQY9Wwe.png" alt="image-20210206220235451"></p><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>Linux操作系统中，每个进程都是通过唯一的进程id标识的。而这个id是一个非负数，每个进程除了id还有其他的标识信息，可以通过相应的函数获得。这些函数在<code>unistd.h</code>头文件中。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid(id)                             获得进程id</span><br><span class="line">pdi_t getppid(id)                            获得进程父进程的id</span><br><span class="line">pid_t getuid()                               获得进程的实际用户id</span><br><span class="line">pid_t geteuid()                              获得进程的有效用户id</span><br><span class="line">pid_t getgid()                               获得进程的实际组id</span><br><span class="line">pid_t getegid()                              获得进程的有效组id</span><br></pre></td></tr></table></figure><p><strong>实际用户id:</strong> 标识运行该进程的用户。<br><strong>有效用户id</strong>: 标识以什么用户身份来运行进程。<br><strong>实际组id</strong>: 它是实际用户所属的组id<br><strong>有效组id</strong>：有效组id是有效用户所属组的id</p><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><ul><li>代码段：存放程序的可执行代码。</li><li>数据段：存放程序的全局变量、常量、静态变量。</li><li>堆栈段：<ul><li>堆用于存放动态分配的内存变量。</li><li>栈用于函数调用，存放函数的参数，内部定义的局部变量。</li></ul></li></ul><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><ul><li><p>运行状态R：进程正在运行或在运行队列中等待运行。</p></li><li><p>可中断等待状态S：进程正在等待某个事件完成，等待过程中可以被信号或定时器唤醒。</p></li><li><p>不可中断等待状态D：进程也在等待某个事件完成，在等待中不可以被信号或定时器唤醒，必须等待直到等待的事件发生。</p></li><li><p>僵死状态Z：进程已终止，但进程描述符依然存在，直到父进程调用<code>wait()</code>函数后释放。</p></li><li><p>停止状态T：进程因为收到SIGSTOP、SIGSTP、SIGTIN、SIGTOU信号后停止运行或者该进程正在被跟踪(调试程序时，进程处于被跟踪状态)。</p><p><img src="https://i.loli.net/2021/02/06/On61Ke8EduabvcF.png" alt="image-20210206223438106"></p></li></ul><p>运行时还会有一些后缀字符，其意义分别为&lt;(高优先级进程),N(低优先级队列),L(内存锁页，即页不可以被换出内存),s(该进程为会话首进程),l(多线程进程),+(进程位于前台进程组)。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p>Linux进程控制包括创建进程、执行新程序、退出进程及改变进程优先级等。</p><p>在Linux系统中，用于对进程进行控制的主要系统调用以下所示:</p><ul><li>fork：用于创建一个新进程</li><li>exit：用于终止进程</li><li>exec：用于执行一个应用程序</li><li>wait：将父进程挂起，等待子进程终止</li><li>getpid： 获取当前进程的ID</li><li>nice： 改变进程的优先级</li></ul><h1 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>创建进程有两种方式，一种是由操作系统创建，二是由父进程创建。</p><p>由操作系统创建的进程。它们是平等的，不存在资源继承关系。而对于父进程创建的进程他们和父进程存在隶属关系。子进程又可以创建进程，这样形成了一个进程家族。子进程可以继承其父进程几乎所有的资源。在系统启动的时候会，操作系统会创建一些进程，它们承担着管理和分配系统资源的任务，这些进程通常被称为系统进程。</p><blockquote><p>系统调用<code>fork</code>是创建一个新进程的唯一方法，除了极少数的方式创建的进程，如<code>init</code>进程，它是内核启动时以特殊方式创建的。进程调用<code>fork</code>函数就是创建了一个子进程。</p></blockquote><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>fork</code>函数调用的时候会返回两个值，实际上调用成功后，当前进程分裂为两个进程，一个是原来的父进程，另一个是刚刚创建的子进程。父子进程在调用<code>fork</code>函数的地方分开，<code>fork</code>函数有两个返回值，一个是函数的父进程调用<code>fork</code>函数后的返回值，这个返回值是刚刚创建的子进程的ID，另一个是子进程中<code>fork</code>函数的返回值，这个返回值是0。<code>fork</code>函数返回两个值的前提是进程创建成功，，如果失败只会返回-1。</p><p>例如 <code>fork.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> fpid; <span class="comment">//fpid表示fork函数的返回值</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    fpid = fork();</span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error in fork!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the child process, my process id is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是爹的儿子\n&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am the parent process, my process id is %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是孩子他爹\n&quot;</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;统计结果是: %d\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wyw@linux:~/linux_c$ ./fork</span><br><span class="line">I am the parent process, my process id is 36738</span><br><span class="line">我是孩子他爹</span><br><span class="line">统计结果是: 1</span><br><span class="line">I am the child process, my process id is 36739</span><br><span class="line">我是爹的儿子</span><br><span class="line">统计结果是: 1</span><br></pre></td></tr></table></figure><blockquote><p>注意：用 <code>fork</code> 创建子进程后，父子进程的执行顺序是不确定的。</p></blockquote><p><strong>属性继承</strong></p><p><code>fork</code>创建的子进程会继承父进程的很多属性，主要包括用户ID、组ID、当前工作目录、根目录、打开的文件、创建的文件使用的屏蔽字、信号屏蔽子、上下文环境、共享存储段、资源限制等。</p><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>孤儿进程就是一个子进程的父进程先于子进程结束，子进程就成为了一个孤儿进程，它由<code>init</code>进程收养，成为init进程的子进程。</p><h3 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h3><p><code>vfork</code>也可以创建新进程，与<code>fork</code>相比，它有自己独特的用处。</p><ul><li><code>vfork</code>和<code>fork</code>一样都是调用一次，返回两次。</li><li>使用<code>fork</code>创建一个子进程时，子进程只是完全复制父进程的资源。这样得到的子进程独立于父进程，并具有良好的并发行。而使用<code>vfork</code>创建一个子进程时，操作系统并不将父进程的地址空间完全复制到子进程，用<code>vfork</code>创建的子进程共享父进程的地址空间，也就是子进程完全运行在父进程地址空间上，子进程对地址空间任何修改对父进程都是可见的。</li><li><code>fork</code>创建的子进程，哪个进程先运行取决于系统的调度算法，但是<code>vfork</code>一个进程时，保证子进程先运行，当他调用<code>exec</code>或者<code>exit</code>之后，父进程才可能被调度运行。如果在<code>exiec</code>或者<code>exit</code>之前要依赖父进程的某个行为，就会导致死锁。</li><li>同时<code>fork</code>创建一个子进程所有父进程的资源都要复制，有时候子进程只是调用一个<code>exec</code>，所以这样会浪费大量的系统资源。而<code>vfork</code> 不会拷贝父进程的地址空间，这样减小了系统开销。</li></ul><p>例如：<code>vfork.c</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">pid = vfork();<span class="comment">// 创建进程</span></span><br><span class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123; <span class="comment">// 出错</span></span><br><span class="line">perror(<span class="string">&quot;vfork&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == pid)&#123; <span class="comment">// 子进程</span></span><br><span class="line">sleep(<span class="number">3</span>); <span class="comment">// 延时 3 秒</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am son\n&quot;</span>);</span><br><span class="line">        a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;son: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">_exit(<span class="number">0</span>); <span class="comment">// 退出子进程，必须</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">// 父进程</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am father\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wyw@linux:~/linux_c$ ./vfork</span><br><span class="line">i am son</span><br><span class="line">son: a = 100, b = 200</span><br><span class="line">i am father</span><br><span class="line">father: a = 100, b = 200</span><br></pre></td></tr></table></figure><p>说明：上面的代码，已经让子进程延时 3 s， 结果还是子进程运行结束后，父进程才执行。</p><p>子进程修改 a, b 的值，会影响到父进程的 a, b, </p><blockquote><p>注意：用 vfork() 创建进程，子进程里一定要调用 exec（进程替换） 或 exit（退出进程），否则，程序会出问题，没有意义。</p></blockquote><h2 id="创建守护进程"><a href="#创建守护进程" class="headerlink" title="创建守护进程"></a>创建守护进程</h2><p>守护进程(daemon)是指在后台运行的、没有控制终端与之相连的进程。他独立于控制终端，通常周期性地执行某种任务。Linux大多数服务器就是用守护进程方式实现的，类似windows的系统服务。</p><blockquote><p>会话和进程组</p><p>进程组是一组相关进程的集合，会话是一组相关进程组的集合。</p><p>当有新的用户登录Linux时，登录进程会为这个用户创建一个会话。用户的登录shell就是会话的首进程。会话的首进程ID会作为整个会话的ID。会话是一个或多个进程组的集合，囊括了登录用户的所有活动。在登录shell时，用户可能会使用管道，让多个进程互相配合完成一项工作，这一组进程属于同一个进程组。</p><p>通常，会话开始于用户登录，终止于用户退出，期间的所有进程都属于这个会话。一个会话一般包含一个会话首进程、一个前台进程组和一个后台进程组，控制终端可有可无；此外，前台进程组只有一个，后台进程组可以有多个，这些进程组共享一个控制终端。</p></blockquote><p><img src="C:\Users\32662\AppData\Roaming\Typora\typora-user-images\image-20210207211130893.png" alt="image-20210207211130893"></p><p>创建步骤：</p><ul><li>fork()创建子进程，父进程exit()退出</li><li>在子进程调用setsid()创建新会话</li><li>再次 fork() 一个子进程，父进程exit退出</li><li>在子进程中调用chdir()让根目录“/”成为子进程的工作目录</li><li>在子进程中调用umask()重设文件权限掩码为0</li><li>在子进程中调用close()关闭不需要的文件描述符</li><li>守护进程退出处理</li></ul><p>例如：<code>daemon.c</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init_daemon</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> pid; </span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1）屏蔽一些控制终端操作的信号</span></span><br><span class="line">signal(SIGTTOU,SIG_IGN); </span><br><span class="line">signal(SIGTTIN,SIG_IGN); </span><br><span class="line">signal(SIGTSTP,SIG_IGN); </span><br><span class="line">signal(SIGHUP ,SIG_IGN);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2）在后台运行</span></span><br><span class="line">    <span class="keyword">if</span>( pid=fork() )&#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//结束父进程，子进程继续</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&lt; <span class="number">0</span>)&#123; <span class="comment">// 出错</span></span><br><span class="line">perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3）脱离控制终端、登录会话和进程组</span></span><br><span class="line">setsid();  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 4）禁止进程重新打开控制终端</span></span><br><span class="line"><span class="keyword">if</span>( pid=fork() )&#123; <span class="comment">// 父进程</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);      <span class="comment">// 结束第一子进程，第二子进程继续（第二子进程不再是会话组长） </span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid&lt; <span class="number">0</span>)&#123; <span class="comment">// 出错</span></span><br><span class="line">perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 5）关闭打开的文件描述符</span></span><br><span class="line"><span class="comment">// NOFILE 为 &lt;sys/param.h&gt; 的宏定义</span></span><br><span class="line"><span class="comment">// NOFILE 为文件描述符最大个数，不同系统有不同限制</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; NOFILE; ++i)&#123;</span><br><span class="line">close(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6）改变当前工作目录</span></span><br><span class="line">chdir(<span class="string">&quot;/&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 7）重设文件创建掩模</span></span><br><span class="line">umask(<span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 8）处理 SIGCHLD 信号</span></span><br><span class="line">signal(SIGCHLD,SIG_IGN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">init_daemon();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="C:\Users\32662\AppData\Roaming\Typora\typora-user-images\image-20210207213739752.png" alt="image-20210207213739752"></p><h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><p>方式：</p><ul><li>正常退出<ul><li>在main函数中执行return</li><li>调用 <code>exit</code> 函数 （头文件<code>stdlib.h</code>）</li><li>调用 <code>_exit</code> 函数 （头文件<code>unistd.h</code>）</li></ul></li><li>异常退出<ul><li>调用 <code>about</code> 函数</li><li>进程收到某个信号，该信号使程序终止。</li></ul></li></ul><h2 id="改变进程的优先级"><a href="#改变进程的优先级" class="headerlink" title="改变进程的优先级"></a>改变进程的优先级</h2><p>改变进程的优先级是通过系统调用<code>nice</code>函数改变。</p><p><code>man 2 nice </code> 命令获取该函数的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br></pre></td></tr></table></figure><p>相关的两个重要函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getpriority                           该函数返回一组进程的优先级。</span><br><span class="line">setpriority                           该函数用来设置制定进程的优先级。</span><br></pre></td></tr></table></figure><h2 id="setuid函数"><a href="#setuid函数" class="headerlink" title="setuid函数"></a>setuid函数</h2><p>可以用 <code>setuid</code> 设置实际用户 ID 和有效用户 ID 。</p><blockquote><p>内核检查一个进程是否具有访问某文件的权限时，是使用进程的有效用户 ID 来进行检查的。<code>su</code> 程序的文件属主是 root,普通用户运行 <code>su</code> 命令时，<code>su</code> 进程的权限是root权限。</p></blockquote><blockquote><p>注意，因为Linux系统中root用户拥有最高权力，黑客们往往喜欢寻找设置了<code>set_uid</code>位的可执行程序的漏洞。这样的程序如果存在缓冲区溢出漏洞，并且该程序是一个网络程序。那么黑客可以从远程的地方轻松的利用该漏洞获得运行该漏洞程序的主机的root权限。即使这样的程序不是网络程序，那么也可以使本机上的恶意普通用户提升为root用户。</p></blockquote><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote><p>关于章末的编程实践：实现自己的 myshell，奈何能力不够，对我来说是很难实现了。这里依然给出学长的代码，可作日后欣赏。(滑稽-&gt; &lt;-)</p><p><a href="https://github.com/Evil-crow/Linux_C/tree/master/Chapter_VII/Shell">https://github.com/Evil-crow/Linux_C/tree/master/Chapter_VII/Shell</a></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Linux C 编程实战第七章进程控制</p><p>[2] <a href="https://blog.csdn.net/mijichui2153/article/details/81394387">创建守护进程的步骤</a></p><p>[3] <a href="https://tennysonsky.blog.csdn.net/article/details/45970087?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">Linux系统编程——特殊进程之守护进程</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux C编程实战之文件操作学习记录</title>
      <link href="posts/46255.html"/>
      <url>posts/46255.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>在 Linux 中，用户可以使用命令对文件进行各种操作，而几条简单命令背后却是大段大段的程序实现代码。Linux C 编程实战第六章文件操作中关于文件的创建，打开，读写，关闭，删除，属性等内容十分详实，这里只是对文件权限和目录配置的内容进行简单记录。</p></blockquote><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>文件主要包含两方面内容：</p><ul><li>文件本身包含的数据</li><li>文件的属性，包括文件访问权限、所有者、文件大小、创建日期等。</li></ul><h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p>在 Linux 中我们可以使用 <code>ll</code> 或者 <code>ls –l</code> 命令来显示一个文件的属性以及文件所属的用户和组，如</p><p><img src="https://i.loli.net/2021/02/14/5ZYD8BEterPkoau.png"></p><p>上面的运行结果从左至右依次是：文件属性、文件数、所属的用户、所属的用户所在的组、文件大小（单位bytes）、文件创建时间、文件名。</p><p>每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。</p><p><img src="https://i.loli.net/2021/02/14/9bF7o31wCz8xJTc.png" alt="image-20210208214725950"></p><p>文件类型：</p><ul><li><code>-</code> 表示普通文件</li><li><code>d</code> 表示目录文件</li><li><code>l</code> 表示链接文件，比如快捷方式</li><li><code>s</code> 套接字文件</li><li><code>c</code> 字符设备文件，比如<code>/dev/</code>中的很多文件</li><li><code>b</code> 表示块设备文件，比如一些磁盘</li><li><code>p</code> 管道文件</li></ul><h2 id="chmod-change-model-改变权限"><a href="#chmod-change-model-改变权限" class="headerlink" title="chmod(change model) 改变权限"></a>chmod(change model) 改变权限</h2><p>对文件的访问权限的修改通过命令 <code>chmod</code> 来进行，如，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 test.c</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/02/08/xk6lKOnWuc8SqFC.png" alt="image-20210208221801438"></p><p>对于可读，可写，可执行三种权限，它们分别对应一个值，<strong>r = 4, w = 2, x = 1</strong></p><p>4+2+1=7，777 表示将test.c 的访问权限修改为：所有者，所属组，其他用户都有读，写，执行的权限。 </p><blockquote><p>r：可读，意思是指可以读取文件的内容</p><p>w：可写，意思就是可以修改文件的内容</p><p>x：可执行，与windows不同，linux下文件可执行与否与后缀名无关，而与x权限属性相关</p></blockquote><p>简化版chmod 命令 <code>my_chmod.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc ,<span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod,mod_u,mod_g,mod_o;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;<span class="comment">//检查参数合法性</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;chmod num&gt;&lt;path&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mod=atoi(argv[<span class="number">1</span>]);<span class="comment">//将字符串转换成整数</span></span><br><span class="line">    <span class="keyword">if</span>(mod&gt;<span class="number">777</span>||mod&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mod num error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mod_u=mod/<span class="number">100</span>;<span class="comment">//所有者权限</span></span><br><span class="line">    mod_g=(mod-mod_u*<span class="number">100</span>)/<span class="number">10</span>;<span class="comment">//所属组权限</span></span><br><span class="line">    mod_o=mod-mod_u*<span class="number">100</span>-mod_g*<span class="number">10</span>;<span class="comment">//其他用户权限</span></span><br><span class="line">    mod=mod_u*<span class="number">8</span>*<span class="number">8</span>+mod_g*<span class="number">8</span>+mod_o;<span class="comment">//八进制转换</span></span><br><span class="line">    path=argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(chmod(path,mod)==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;chmod error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://i.loli.net/2021/02/14/wjXe4DOBRJH8dKi.png" alt="image-20210208223940269"></p><p>可见 test.c 文件的权限已被修改。</p><h2 id="chgrp-change-group-改变用户组"><a href="#chgrp-change-group-改变用户组" class="headerlink" title="chgrp(change group) 改变用户组"></a>chgrp(change group) 改变用户组</h2><p>重要参数：<code>-R</code> 递归改变权限，即把该目录下的文件，目录的权限全部同步修改，很好用，也很危险！</p><p>语法： <code>chgrp [-R] group dirname/filename </code> (目录/文件名）</p><p>如下例所示：</p><p><img src="https://i.loli.net/2021/02/14/y41IJtP8jQbzuZM.png" alt="image-20210214083539619"></p><h2 id="chown-change-owner-改变用户"><a href="#chown-change-owner-改变用户" class="headerlink" title="chown(change owner) 改变用户"></a>chown(change owner) 改变用户</h2><p>重要参数：同上 [-R]，递归更改用户</p><p>语法：<code>chown [-R] owner dirname/filename</code> 改变所属用户</p><p> <code>chown [-R] owner:group dirname/filename</code>  改变所属用户，用户组</p><p><code> chown [-R] .group dirname/filename</code>  改变所属用户组</p><p>如下例所示：</p><p><img src="https://i.loli.net/2021/02/14/WO9xomFzcJjk2Mf.png" alt="image-20210214084556022"></p><h1 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h1><p>linux系统的发行版本众多，如果更换一个版本的Linux系统，就需要重新学习Linux系统的目录配置，岂不是很麻烦？？？所以制定了FHS，即 Filesystem Hierarchy Standard(文件系统配置标准)，以此来进行目录配置规范。</p><p>FHS标准对于Ｌinux系统的目录配置文件，只定义了三层目录配置：</p><blockquote><p>/ (root)目录：与开机系统有关</p><p>/usr目录：与软件安装/执行有关</p><p>/var目录：与系统运作过程有关</p></blockquote><h2 id="根目录"><a href="#根目录" class="headerlink" title="/ 根目录"></a>/ 根目录</h2><p>/ 根目录，是Linux系统中最重要的一个目录了！所有的目录都是由根目录所衍生出来的，而且根目录还与机器的开机，还原，系统修复有关。根目录下的一些目录：</p><p><img src="https://i.loli.net/2021/02/14/sHxG1fSZFO2MgIV.png" alt="image-20210214215243141"></p><table><thead><tr><th align="center">目录</th><th align="center">应放置的文件内容</th></tr></thead><tbody><tr><td align="center">/bin</td><td align="center">bin为binary的简写，主要放置系统的必备执行文件，例如：cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等。</td></tr><tr><td align="center">/boot</td><td align="center">/boot中存放内核文件以及开机配置文件</td></tr><tr><td align="center">/dev</td><td align="center">之前讲一切皆文件，/dev目录下都是设备文件</td></tr><tr><td align="center">/etc</td><td align="center">系统的主要配置文件都存放在此处</td></tr><tr><td align="center">/home</td><td align="center">home目录即为用户目录</td></tr><tr><td align="center">/lib</td><td align="center">系统开机时所用到的函数库</td></tr><tr><td align="center">/media</td><td align="center">“媒体”，指软盘，光盘等设备</td></tr><tr><td align="center">/mnt</td><td align="center">用于暂时挂载的目录</td></tr><tr><td align="center">/opt</td><td align="center">用于给第三方软件放置的目录</td></tr><tr><td align="center">/root</td><td align="center">系统管理员目录</td></tr><tr><td align="center">/sbin</td><td align="center">主要放置系统管理的必备程序，例如：dump、halt、ifconfig、ifup、 ifdown、init、reboot、rmmod、 runlevel、shutdown等。</td></tr><tr><td align="center">/tmp</td><td align="center">一般用户或者暂时放置数据的地方</td></tr><tr><td align="center">/lost+found</td><td align="center">文件系统发生错误时,将一些丢失的片段放在该目录下</td></tr><tr><td align="center">/proc</td><td align="center">该目录是一个虚拟的文件系统,放置的数据都是在内存当中的,例如系统的内核,进程,外部设备的状态,网络状态等</td></tr><tr><td align="center">/sys</td><td align="center">存放着已加载的内核模块和内核监测到的硬件设备信息等</td></tr></tbody></table><h2 id="usr-目录"><a href="#usr-目录" class="headerlink" title="/usr 目录"></a>/usr 目录</h2><p>/usr(UNIX Software Resource)是与软件的安装/执行有关的目录，所存放的是<strong>可分享的</strong>与<strong>不可变动的</strong>数据文件。其下目录有：</p><p><img src="https://i.loli.net/2021/02/14/ESNVbWyB3wK2ZPi.png" alt="image-20210214220013565"></p><table><thead><tr><th>目录</th><th>应放置的文件内容</th></tr></thead><tbody><tr><td>/usr/bin/</td><td>绝大部分的用户可使用命令都在此处</td></tr><tr><td>/usr/include/</td><td>C/C++的头文件,包含文件都在此处</td></tr><tr><td>/usr/lib/</td><td>各类应用软件的函数库,目标文件以及一些非惯用的执行文件或脚本</td></tr><tr><td>/usr/local/</td><td>用户自行安装的软件都在此处,区别于发行版自带的软件</td></tr><tr><td>/usr/sbin/</td><td>非系统正常运行所需要的系统命令</td></tr><tr><td>/usr/share/</td><td>放置共享文件</td></tr><tr><td>/usr/src/</td><td>一般源码存放在这里,而内核源码存放在/usr/src/linux下</td></tr></tbody></table><p>显然，/usr与 / 下有不少相同的目录,接下来就看看它们的区别:</p><ul><li>/bin 与 /usr/bin</li></ul><p>/bin是根目录下的目录,其与开机过程有关,所以要放在开机时就挂载的/目录下</p><p>/usr/bin 中存放的也是一般用户所能用到的大多数命令,但是与开机过程不挂钩</p><ul><li>/lib 与 /usr/lib</li></ul><p>/lib中放置的是在开机时首先会用到的函数库</p><p>/usr/lib中放置的则是各种应用软件的函数库,不一定开机时会用到</p><ul><li>/sbin 与 /usr/sbin</li></ul><p>/sbin中存放的是超级用户 root一般使用的命令放置着系统管理所必须的程式</p><p>/usr/sbin中放置的则不一定是系统正常运行所必须的系统指令</p><ul><li>/opt 与 /usr/local</li></ul><p>/opt目录下存放第三方软件,即并非发行版Linux安装时就装的软件</p><p>/usr/local目录下存放系统管理员在本机安装的软件,一般经由 apt 或 yum 安装的软件都放置于此</p><h2 id="var-目录"><a href="#var-目录" class="headerlink" title="/var 目录"></a>/var 目录</h2><p>/var (variable)是与系统运作过程有关的目录。</p><p><img src="https://i.loli.net/2021/02/14/sUN38Vcpvul4zCx.png" alt="image-20210214221639768"></p><table><thead><tr><th>目录</th><th>放置的文件内容</th></tr></thead><tbody><tr><td>/var/cache/</td><td>应用程序本身产生的缓存文件</td></tr><tr><td>/var/lib</td><td>程序运行时需要的数据放置的目录</td></tr><tr><td>/var/lock</td><td>程序锁,对于只能同时一个用户使用的程序上锁,防止两人同时使用</td></tr><tr><td>/var/log</td><td>登录文件放置的目录</td></tr><tr><td>/var/mail</td><td>个人信箱的目录</td></tr><tr><td>/var/run</td><td>程序的PID放置目录</td></tr><tr><td>/var/spool</td><td>通常放置一些队列数据</td></tr></tbody></table><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote><p>关于章末的编程实践：实现自己的 ls 命令，这里先给出学长的代码，待日后再细品。(滑稽-&gt; &lt;-)</p><p><a href="https://blog.csdn.net/qq_45858169/article/details/105193172">Linux系统编程：my_ls(l、R、A、r、n、h、i、颜色的实现)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之常用命令</title>
      <link href="posts/18120.html"/>
      <url>posts/18120.html</url>
      
        <content type="html"><![CDATA[<p>在了解Linux 常用命令之前，有必要知道以下两个概念。</p><h1 id="Linux-终端"><a href="#Linux-终端" class="headerlink" title="Linux 终端"></a>Linux 终端</h1><p>Linux 把显示器和键盘合称为终端，因为它们可以对系统进行控制并且可以用软件的方式来实现，所以又称为虚拟控制台。</p><h1 id="Linux-Shell"><a href="#Linux-Shell" class="headerlink" title="Linux Shell"></a>Linux Shell</h1><p>在终端上，通过输入Shell 命令来控制和使用计算机。Shell 是一个命令解释器，它通过接受用户输入的命令来启动、暂停、停止程序的运行或对计算机进行控制。</p><p>Shell有两种提示符：以**#**为提示符表明该终端是由root 用户打开的，root用户具有系统最高权限，因此可以输入任何可用的命令，而一般用户打开的终端的提示符是 $ 。提示符的其他部分分别表示：[登录用户名@主机名当前目录]。</p><p>Shell命令的基本格式是:<br>命令名  [选项]  &lt;参数1&gt;  &lt;参数2&gt;.…..</p><p>其中方括号中的选项对命令来说是可选的，一条命令可以有0个或多个参数。选项是对命令的特别定义，也可以理解为选项告诉命令具体做什么。选项通常以“-”开始，后接一个或多个字母，如 ls-al，有的选项以“–”开头，后面一般跟着一个单词，比如–number。很多“–”格式的选项可以用“-”加上第一个字母来替代，如–number_可以用-n来替代。在 Shell下输入相应的命令并按回车键，Shell就执行命令。如果没有此命令，Shell会提示·“command not found”，表明没有这个命令。Shell 命令是区分大小写的，一条命令只要有一个字母的大小写发生变化，系统就认为是一条不同的命令。可以用分号“;”来连接多个命令，Shell 会依次执行这些命令。</p><h1 id="man-page-与-info-page"><a href="#man-page-与-info-page" class="headerlink" title="man page 与 info page"></a>man page 与 info page</h1><p>Linux命令数量众多，你能完全掌握它们的功能吗？你能了解它们的每一个选项，每一个参数吗？这个时候就需要用到强大的在线求助 <strong>man page</strong></p><p>man 也是命令，为manual(操作说明）<code>man command</code>即可显示此命令的操作说明。</p><p>举个例子：</p><p>man ls 即可显示关于 ls 命令的所有内容，包括其用法，等级，相关环境参数等一系列信息</p><p>而使用 man命令时会进入一个界面，此即所谓的 man page，在其中也可以使用许多快捷键进行操作。</p><blockquote><p>可以说，通过man命令即可了解到所有的命令相关的操作说明。虽然Linux中有许多许多的命令，你背不完所有的命令，你也不需要背所有的命令，记住平时常用的命令，然后灵活使用man 与 Tab键补全即可完成许多操作。</p></blockquote><p>info page的用法与 man page基本类似，但是，在info中将文件数据折叠成一个个段落，更方便使用者的查询与查看。</p><h1 id="几个简单命令"><a href="#几个简单命令" class="headerlink" title="几个简单命令"></a>几个简单命令</h1><ul><li><code>date</code> 显示当前日期与时间</li><li><code>cal</code> 显示本月日历；<code>cal [month] [year]</code> 显示指定时间日历</li><li><code>bc</code> 打开计算器（数据默认整型）；可通过<code>scale = number</code> 保留小数位数，number即为要保留的小数位数；<code>quit</code> 退出计算器</li><li> <code>pwd</code> 显示当前目录的路径</li><li> <code>du -h file</code> 查看文件大小</li><li> <code>useradd zhang3</code> 创建新用户张三</li><li> <code>passwd zhang3</code> 设置用户密码</li><li> <code>chpasswd zhang3</code> 更改用户密码</li><li> <code>userdel zhang3</code> 删除用户张三</li></ul><h1 id="几个常用热键"><a href="#几个常用热键" class="headerlink" title="几个常用热键"></a>几个常用热键</h1><ul><li>&lt; Tab &gt;键补全 </li></ul><p>输入命令、目录名或文件名的开头一个或几个字母后按下 <strong>&lt; Tab &gt;键</strong>，Shell 会在相应目录里进行匹配，自动补齐命令、目录名或文件名。在命令、目录名或文件名很长或难以记忆时，自动补齐功能会很有用。</p><ul><li>&lt;↑&gt;和&lt;↓&gt;键</li></ul><p>可以通过按&lt;↑&gt;或&lt;↓&gt;键来显示执行过的命令，这在重复执行某些命令时会给用户带来很大的便利。</p><ul><li>&lt; Ctrl &gt; + C 终止进程</li></ul><p>有时候避免不了的，会进行了错误的进程，那么怎么办？按下&lt; Ctrl&gt; + C可以解决这个而问题，会强制终止进程。虽然好用，但是有的时候，也需要谨慎使用，不能肆意使用，否则会引起重大错误的出现。</p><ul><li>&lt; Ctrl &gt; + D 结束输入</li></ul><p>使用&lt; Ctrl &gt; + D可迅速结束从键盘的输入，相当于输入exit()一样。</p><ul><li>&lt; Ctrl &gt; + L  清理屏幕</li></ul><h1 id="文件与目录管理常用命令"><a href="#文件与目录管理常用命令" class="headerlink" title="文件与目录管理常用命令"></a>文件与目录管理常用命令</h1><h2 id="cd-改变当前目录命令"><a href="#cd-改变当前目录命令" class="headerlink" title="cd 改变当前目录命令"></a>cd 改变当前目录命令</h2><p>格式：cd &lt;目录名&gt;</p><p>例如：执行命令 <code>cd/home/admin</code>，则切换到目录/home/admin 下。</p><p>例如：执行命令 <code>cd～</code>，则当前目录位于用户的主目录下。</p><p>例如：执行命令 <code>cd.. </code>，切换到当前目录的父目录。</p><p>例如：执行命令 <code>cd - </code>，切换到前一个目录。</p><h2 id="ls-显示目录或文件信息命令"><a href="#ls-显示目录或文件信息命令" class="headerlink" title="ls 显示目录或文件信息命令"></a>ls 显示目录或文件信息命令</h2><p>格式：ls [选项] &lt;目录或文件名&gt;</p><p>主要选项如下：<br>-a：显示所有的文件和目录。</p><p>-l：以长格式显示文件信息。</p><p>-t：将结果按修改时间进行排序，新的文件或目录排在前面。</p><h2 id="cat-文件内容查看和连接命令"><a href="#cat-文件内容查看和连接命令" class="headerlink" title="cat 文件内容查看和连接命令"></a>cat 文件内容查看和连接命令</h2><p>格式：cat [选项] &lt;文件1&gt; &lt;文件2&gt; ….</p><p>该命令用于把几个文件的内容连接后显示在屏幕上。主要选项如下：</p><p>-n：对内容进行按行编号输出。</p><p>例如：执行命令<code>cat -n test.c</code>，表示将文件test.c的内容加上行号后显示输出。<br>例如：执行命令<code>cat test1.c test2.c</code>，表示将文件test1.c和 test2.c的内容串接在一起并输出。</p><blockquote><p>针对比较大的文件，我们就可以使用<code>less</code>命令打开某个文件。类似vim，less可以在输入<code>/</code>后进入查找模式，然后按<code>n</code>(N)向下(上)查找。<code>空格</code> 向下滚屏翻页，<code>b</code> 向上滚屏翻页， <code>q</code> 退出less</p></blockquote><h2 id="cp-文件复制命令"><a href="#cp-文件复制命令" class="headerlink" title="cp 文件复制命令"></a>cp 文件复制命令</h2><p>格式：cp [选项] &lt;源文件或目录&gt; &lt;目标文件或目录&gt;</p><p>该命令用于把一个文件拷贝到另一个文件或将多个文件拷贝到一个目录下。主要选项如下：</p><p>-r：若源目录下还有文件或目录，则都拷贝到目的地。</p><p>-f：若目标目录下已经有同名的文件，则把它删除并把源文件拷贝到目标目录下。</p><p>例如：执行命令<code>cp test.c tmp/program.c</code>，表示把当前目录下的test.c文件拷贝到/tmp目录下并命名为program.c</p><h2 id="mkdir-创建目录命令"><a href="#mkdir-创建目录命令" class="headerlink" title="mkdir 创建目录命令"></a>mkdir 创建目录命令</h2><p>格式：mkdir [选项] &lt;目录&gt;</p><p>如果指定目录不存在则创建它。主要选项如下：</p><p>-p：若要建立的目录的上层目录不存在，则先创建它。</p><p>例如：执行命令<code>mkdir-p dir1/dir2</code>，表示在当前目录下创建dir1/dir2，如果dir1不存在则先创建它。</p><h2 id="touch-创建文件命令"><a href="#touch-创建文件命令" class="headerlink" title="touch 创建文件命令"></a>touch 创建文件命令</h2><p>格式：touch &lt;文件&gt;</p><p>例如：执行命令<code> touch test.c</code>命令在当前目录下创建一个文件test.c，前提是test.c文件不存在。</p><h2 id="rm-删除文件命令"><a href="#rm-删除文件命令" class="headerlink" title="rm 删除文件命令"></a>rm 删除文件命令</h2><p>格式：rm [选项] &lt;文件或目录&gt;</p><p>该命令用于删除文件，主要选项如下：</p><p>-r：若目录非空,则删除目录下所有的文件。</p><p>-f：强制删除。<br>例如：执行命令<code>rm *.c</code>，表示删除当前目录下所有以.c结尾的文件。<br>例如：执行命令<code>rm -rf tyq</code>，表示强制删除 tyq目录下所有的文件和子目录，子目录下的文件或目录都被删除。</p><h2 id="rmdir-删除目录命令"><a href="#rmdir-删除目录命令" class="headerlink" title="rmdir 删除目录命令"></a>rmdir 删除目录命令</h2><p>格式：mkdir [选项] &lt;目录&gt;</p><p>如果指定目录为空就删除它，若不为空则出现错误信息。主要选项如下：</p><p>-p：当删除指定目录后,若该目录的父目录为空,则也将其删除。</p><p>例如：执行命令<code>rmdir -p dir1/dir2</code>，表示在当前目录下的dir1目录中删除dir2子目录，若删除dir2后dir1变为空目录，则也将其删除。</p><h2 id="mv-移动或重命名文件命令"><a href="#mv-移动或重命名文件命令" class="headerlink" title="mv 移动或重命名文件命令"></a>mv 移动或重命名文件命令</h2><p>格式：mv [选项] &lt;源文件或目录&gt; &lt;目的文件或目录&gt;</p><p>该命令用于对一个文件或目录进行重命名或将几个文件移到另一目录。主要选项如下：</p><p>-f：强制移动,若目标目录下有同名的文件则覆盖它。</p><p>例如：执行命令<code>mv test.c program.c</code>，则将当前目录下的test.c文件重命名为program.c。</p><h1 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h1><p>为了减小传输文件的大小，一般都开启压缩。linux下常见的压缩文件有tar、bzip2、zip、rar等，7z这种用的相对较少。</p><p><strong>.tar</strong> 使用tar命令压缩或解压</p><p><strong>.bz2</strong> 使用bzip2命令操作</p><p><strong>.gz</strong> 使用gzip命令操作</p><p><strong>.zip</strong> 使用unzip命令解压</p><p><strong>.rar</strong> 使用unrar命令解压</p><p>最常用的就是<code>.tar.gz</code>文件格式了。其实是经过了tar打包后，再使用gzip压缩。</p><p>创建压缩文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf test.tar.gz ./</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure><h1 id="vi-vim编辑器的简单使用"><a href="#vi-vim编辑器的简单使用" class="headerlink" title="vi/vim编辑器的简单使用"></a>vi/vim编辑器的简单使用</h1><p>Vi (visual interface) 是Linux上主要的文本编辑软件。它可以进行文本输入、删除、查找、替换、块操作等诸多文本操作。但是目前我们使用比较多的是 vim 编辑器。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。基本操作如下图：</p><p><img src="C:\Users\32662\AppData\Roaming\Typora\typora-user-images\image-20210208112035571.png" alt="image-20210208112035571"></p><h1 id="gcc-编译器的简单使用"><a href="#gcc-编译器的简单使用" class="headerlink" title="gcc 编译器的简单使用"></a>gcc 编译器的简单使用</h1><p>Linux 下最常用的C 语言编译器是 gcc (GNU Compiler Collection)。</p><p>编译过程：</p><p>（1）预处理</p><p>（2）编译</p><p>（3）汇编</p><p>（4）链接</p><p>源文件 test.c 生成可执行文件 test 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>如果未指定文件名，默认生成可执行文件 <code>a.out</code> </p><h1 id="apt-命令与-yum-命令"><a href="#apt-命令与-yum-命令" class="headerlink" title="apt 命令与 yum 命令"></a>apt 命令与 yum 命令</h1><blockquote><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p><p>apt 命令执行需要超级管理员权限(root)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su root <span class="comment">#su命令用于切换用户</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="apt-语法"><a href="#apt-语法" class="headerlink" title="apt 语法"></a>apt 语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt [options] [<span class="built_in">command</span>] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package</strong>：安装的包名。</li></ul><h2 id="apt-常用命令"><a href="#apt-常用命令" class="headerlink" title="apt 常用命令"></a>apt 常用命令</h2><ul><li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p></li><li><p>升级软件包：<strong>sudo apt upgrade</strong></p></li><li><p>安装指定的软件命令：<strong>sudo apt install <package_name></strong></p><p>安装多个软件包：<strong>sudo apt install <package_1> <package_2> <package_3></strong></p></li><li><p>更新指定的软件命令：<strong>sudo apt update <package_name></strong></p></li><li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show <package_name></strong></p></li><li><p>删除软件包命令：<strong>sudo apt remove <package_name></strong></p></li><li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p></li><li><p>移除软件包及配置文件: <strong>sudo apt purge <package_name></strong></p></li><li><p>列出所有已安装的包：<strong>apt list –installed</strong></p></li><li><p>列出所有已安装的包的版本信息：<strong>apt list –all-versions</strong></p></li></ul><blockquote><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora、CentOS和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p><p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p></blockquote><h2 id="yum-语法"><a href="#yum-语法" class="headerlink" title="yum 语法"></a>yum 语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package：</strong>安装的包名。</li></ul><h2 id="yum-常用命令"><a href="#yum-常用命令" class="headerlink" title="yum 常用命令"></a>yum 常用命令</h2><ul><li>列出所有可更新的软件清单命令：<strong>yum check-update</strong></li><li>更新所有软件命令：<strong>yum update</strong></li><li>仅安装指定的软件命令：<strong>yum install <package_name></strong></li><li>仅更新指定的软件命令：<strong>yum update <package_name></strong></li><li>删除软件包命令：<strong>yum remove <package_name></strong></li><li>清除缓存命令： <strong>yum clean all</strong> </li></ul><h1 id="服务相关命令"><a href="#服务相关命令" class="headerlink" title="服务相关命令"></a>服务相关命令</h1><ul><li><code>systemctl start apache2</code> (<code>service apache2 start</code>) 启动apache服务</li><li><code>systemctl stop apache2</code>(<code>service apache2 stop</code>) 停止apache服务</li><li><code>systemctl restart apache2</code> (<code>service apache2 restart</code>) 重启apache服务</li><li><code>systemctl status apache2</code> (<code>service apache2 status</code>) 查看apache运行状态</li><li><code>systemctl enable apache2.service   </code> 设为开机自动运行服务</li><li><code>systemctl disable apache2.service      </code> 取消开机自动运行服务</li></ul><h1 id="查看系统状态命令"><a href="#查看系统状态命令" class="headerlink" title="查看系统状态命令"></a>查看系统状态命令</h1><p>登陆一台linux机器，有些命令能够帮助你快速找到问题。这些命令涵盖内存、cpu、网络、io、磁盘等。</p><ul><li><code>uname</code>命令可以输出当前的内核信息，让你了解到用的是什么机器。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux linux 5.4.0-58-generic <span class="comment">#64-Ubuntu SMP Wed Dec 9 08:16:25 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><ul><li><code>ps</code>命令能够看到进程/线程状态。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到java进程</span></span><br><span class="line">ps -ef|grep java</span><br></pre></td></tr></table></figure><ul><li><code>top</code>系统状态一览，主要查看cpu load负载、cpu占用率，使用内存或者cpu最高的一些进程。</li><li><code>df</code>命令用来查看系统中磁盘的使用量，用来查看磁盘是否已经到达上限。<code>df -h</code>可以以友好的方式进行展示。</li><li><code>ifconfig</code> 查看ip地址</li><li><code>ping</code> 检测网络连接</li><li><code>netstat</code>虽然<code>ss</code>命令可以替代<code>netstat</code>了，但现实中netstat仍然用的更广泛一些。比如，查看当前的所有tcp连接。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找本地端口相关</span></span><br><span class="line">netstat -ant </span><br></pre></td></tr></table></figure><hr><p>待补充。。。</p><blockquote><p>参考资料：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MDEwNzAzNg==&mid=2649451542&idx=1&sn=d49f71ee4d00fda3e366dc9ad1a40028&chksm=f3a24d65c4d5c473073259d0902bca1fff65c2ee94116643bb2f3764dc3f789396760d99ce09&mpshare=1&scene=23&srcid=0119KZZGVA1O4x64iOgBcCQG&sharer_sharetime=1613318033634&sharer_shareid=0682904b850da48c54cd507e190afd60#rd">看完这篇你一定能掌握Linux（非广告）</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu20.04安装记录</title>
      <link href="posts/2811.html"/>
      <url>posts/2811.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从手机，到服务器上广泛使用的<code>centos</code>，到漂亮的桌面发行版<code>ubuntu</code>，甚至是风靡全球的<code>树莓派</code>，到处都是linux的身影。Linux系统的发行版本众多，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。这里选择基于debian发行版和gnome桌面环境的Ubuntu 进行安装体验。</p><h1 id="安装VMware虚拟机"><a href="#安装VMware虚拟机" class="headerlink" title="安装VMware虚拟机"></a>安装VMware虚拟机</h1><p>排除掉实体机和双系统的运行方式，这里选择在虚拟机上运行Linux系统。</p><p>前往 <a href="https://www.vmware.com/">官网</a> 下载Vmware虚拟机软件</p><p><img src="https://i.loli.net/2020/11/15/DzHwdn3cAE85r14.png" alt="image-20201115160332451"></p><p>选择VMware Workstation Pro 16.0 for Windows下载（当前最新版）</p><p><img src="https://i.loli.net/2021/02/14/uKN3eWxZvnDcHFE.png" alt="image-20201115233840538"></p><p>下载好后选择位置默认安装即可。</p><h1 id="安装Ubuntu系统"><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h1><h2 id="下载镜像文件"><a href="#下载镜像文件" class="headerlink" title="下载镜像文件"></a>下载镜像文件</h2><p>版本选择：ubuntu 20.04.1 LTS  <a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p><p>下载速度慢的话可以在中科大源下载  <a href="http://mirrors.ustc.edu.cn/">http://mirrors.ustc.edu.cn/</a></p><p><img src="https://i.loli.net/2020/11/15/LtSJsK5iMAx7pwB.png" alt="image-20201115155320583"></p><h2 id="创建Ubuntu虚拟机"><a href="#创建Ubuntu虚拟机" class="headerlink" title="创建Ubuntu虚拟机"></a>创建Ubuntu虚拟机</h2><p>打开vmware，选择创建新的虚拟机</p><p><img src="https://i.loli.net/2021/02/14/sAEG7QtKn1VpFPu.png"></p><p>选择自定义</p><p><img src="https://i.loli.net/2021/02/14/9AQZcTNPCKwLIyj.png"></p><p>选择稍后安装操作系统</p><p><img src="https://i.loli.net/2021/02/14/XkqDy5OlRbdjFsC.png" alt="image-20201116000036529"></p><p>选择Linux，ubuntu 64位</p><p><img src="https://i.loli.net/2021/02/14/l6ijyQ9JOaZbn5m.png" alt="image-20210214233038803"></p><p>根据电脑配置选择处理器数量，这里主机是八核处理器，数量选择如下：</p><p><img src="https://i.loli.net/2021/02/14/EnyZA9Hztg1dkav.png" alt="image-20201116000356510"></p><p>选择内存大小</p><p><img src="https://i.loli.net/2021/02/14/u8zUF9r3mcEikew.png" alt="image-20201116000607760"></p><p>网络类型，I/O控制器类型，磁盘类型，磁盘选择默认即可</p><p>磁盘大小选择</p><p><img src="https://i.loli.net/2021/02/14/aY6USWJkV2FMd1K.png" alt="image-20201116000919973"></p><p>指定磁盘文件默认即可</p><p>选择自定义硬件</p><p><img src="https://i.loli.net/2021/02/14/ICp4WovQNLgwfhJ.png" alt="image-20201116001105197"></p><p>完成下列操作后关闭</p><p><img src="https://i.loli.net/2021/02/14/nImLyf2QxO8whrY.png" alt="image-20201116001519587"></p><h2 id="开启Ubuntu"><a href="#开启Ubuntu" class="headerlink" title="开启Ubuntu"></a>开启Ubuntu</h2><p>开启此虚拟机</p><p><img src="https://i.loli.net/2021/02/14/wD5JBGOqYdAozV7.png" alt="image-20201116001750169"></p><p>稍作等待至Install</p><p><img src="https://i.loli.net/2021/02/14/49SrsLCKF2oDJWc.png" alt="image-20201116002343400"></p><p>continue</p><p>Install Now</p><p><img src="https://i.loli.net/2021/02/14/U8YJpZNzCwnq6ht.png" alt="image-20201116002715987"></p><p>continue</p><p>选择地区</p><p><img src="https://i.loli.net/2021/02/14/wOvuteENrPfJndX.png" alt="image-20201116002811568"></p><p>设置用户名和密码</p><p><img src="https://i.loli.net/2021/02/14/Si7dgGltbWzqDrK.png" alt="image-20201116002948041"></p><p>等待系统相关配置</p><p><img src="https://i.loli.net/2021/02/14/NsE1MP8TKf3ilLC.png" alt="image-20201116003202060"></p><p>restart重启</p><p><img src="https://i.loli.net/2021/02/14/biNThdJmnZR7u8L.png" alt="image-20201116003825147"></p><p>使用刚才创建的账户登录</p><p><img src="https://i.loli.net/2021/02/14/QDU7ByJXNYEMCKz.png" alt="image-20201116004426112"></p><p>Skip</p><p><img src="https://i.loli.net/2021/02/14/LVQ12ilHdPXMEqp.png" alt="image-20201116004531824"></p><p>Next…</p><p><img src="https://i.loli.net/2021/02/14/6WrVKNH9IcumfXQ.png" alt="image-20201116004603633"></p><p>到此可以看到Ubuntu桌面了</p><p><img src="https://i.loli.net/2021/02/14/PU12Ew3kDmZs85H.png" alt="image-20201116004750134"></p><h2 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h2><blockquote><p>VMware Tools作用:</p><p>可以在本机和虚拟机之间拖拽文件</p><p>使虚拟机的屏幕充满VMware Workstation的窗口</p></blockquote><p>1、选择“虚拟机” -&gt; “安装VMware Tools”，这里已经安装过了，所以显示灰色</p><p><img src="https://i.loli.net/2021/02/15/UIajiyv9pGWwcDV.png" alt="image-20210215015014854"></p><p>2、点击后可以在桌面看到一个压缩包，打开终端把压缩包解压到某个路径。</p><p>3、解压完之后，进入解压路径，就会看VMware Tools的安装包。</p><p>4、进入安装包，打开终端，执行安装程序。</p><p>5、开始安装之后见到yes，就输入yes。其他的就一路回车按（Enter）直到出现“Enjoy, –the VMware team”就表示安装成功了，然后手动重启虚拟机，虚拟机的屏幕就充满VMware Workstations的窗口了。</p><p>详情可见这篇<a href="https://blog.csdn.net/engerla/article/details/83009677">文章</a></p><h2 id="更换镜像源"><a href="#更换镜像源" class="headerlink" title="更换镜像源"></a>更换镜像源</h2><p>用默认的镜像源可能会导致下载速度过慢，有必要更换国内的镜像源。</p><p>进入软件 Software &amp; Updates 进行更换</p><p><img src="https://i.loli.net/2021/02/15/ea3suvftd8kbRP5.png" alt="image-20210215020614139">  </p><p>在 Download from 一栏中选择Others，找到 China，选择国内的镜像源，这里选择阿里云。</p><p><img src="https://i.loli.net/2021/02/15/fwx8IG4c9DQqa2b.png" alt="image-20210215020740306"></p><p>选好后输入密码，点击 Close，千万别点 Revert</p><p>到此更换完成。</p><blockquote><p>基本配置弄好后，就尽情享用 Ubuntu 吧！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gulp压缩初体验</title>
      <link href="posts/175.html"/>
      <url>posts/175.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="http://gulpjs.com/">Gulp</a>  是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。</p></blockquote><ul><li>搭建web服务器</li><li>文件保存时自动重载浏览器</li><li>使用预处理器如Sass、LESS</li><li>优化资源，比如压缩CSS、JavaScript、压缩图片</li></ul><p>当然Gulp能做的远不止这些。这里也只是简单利用它来压缩html,css,js文件，一定程度上减缓站点加载过慢的问题。</p><h1 id="Gulp的安装"><a href="#Gulp的安装" class="headerlink" title="Gulp的安装"></a>Gulp的安装</h1><p>首先确保已经正确安装了node.js环境，然后以全局方式安装gulp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g gulp</span><br></pre></td></tr></table></figure><p>全局安装gulp后，还需要在每个要使用gulp的项目中都单独安装一次。把目录切换到你的项目文件夹中，然后在命令行中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp  // --save-dev用于把gulp写进项目package.json文件的依赖中</span><br></pre></td></tr></table></figure><h1 id="Gulp的使用"><a href="#Gulp的使用" class="headerlink" title="Gulp的使用"></a>Gulp的使用</h1><h2 id="建立gulpfile-js文件"><a href="#建立gulpfile-js文件" class="headerlink" title="建立gulpfile.js文件"></a>建立gulpfile.js文件</h2><p>在项目根目录下新建一个文件名为<code>gulpfile.js</code>的文件，之后要做的事情就是在<code>gulpfile.js</code>文件中定义我们的任务了。下面是这次的 <code>gulpfile.js</code> 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-uglify&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> minifyCSS = <span class="built_in">require</span>(<span class="string">&#x27;gulp-minify-css&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> htmlminify = <span class="built_in">require</span>(<span class="string">&#x27;gulp-html-minify&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩js</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line"> <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./*.js&#x27;</span>) </span><br><span class="line"> .pipe(uglify())</span><br><span class="line"> .pipe(gulp.dest(<span class="string">&#x27;./&#x27;</span>)) </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩css</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-css&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./*.css&#x27;</span>)</span><br><span class="line"> .pipe(minifyCSS())</span><br><span class="line"> .pipe(gulp.dest(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩html</span></span><br><span class="line">gulp.task(<span class="string">&#x27;minify-html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">&#x27;./*.html&#x27;</span>)</span><br><span class="line">    .pipe(htmlminify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">&#x27;./&#x27;</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>API</p><ul><li>gulp.task(‘name’, function(){})    定义任务</li><li>gulp.src(‘path’)    从该路径读取要被压缩的文件</li><li>gulp.dest(‘path’)    把压缩后的文件写入该路径</li></ul><h2 id="安装gulp插件"><a href="#安装gulp插件" class="headerlink" title="安装gulp插件"></a>安装gulp插件</h2><p>这里需要安装</p><ul><li>gulp-uglify  用于压缩js文件大小</li><li>gulp-minify-css  用于压缩css文件大小</li><li>gulp-html-minify  用于压缩html文件大小</li></ul><h2 id="运行gulp任务"><a href="#运行gulp任务" class="headerlink" title="运行gulp任务"></a>运行gulp任务</h2><p>插件安装完成后,使用 <code>gulp</code> 后面可以加上要执行的任务名，例如<code>gulp task1</code>，如果没有指定任务名，则会执行任务名为<code>default</code>的默认任务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp task_name</span><br></pre></td></tr></table></figure><h1 id="Gulp使用前后"><a href="#Gulp使用前后" class="headerlink" title="Gulp使用前后"></a>Gulp使用前后</h1><p>压缩前</p><p><img src="https://i.loli.net/2021/01/31/RXSA3Ob6CdPxvn1.png" alt="image-20210131230716274"></p><p>压缩中</p><p><img src="https://i.loli.net/2021/01/31/EMfnGihjT3N19z6.png" alt="image-20210131231014617"></p><p>压缩后</p><p><img src="https://i.loli.net/2021/01/31/Aw4k1GNKv2n67Zh.png" alt="image-20210131231059152"></p><p>这里初次窥见了gulp的强大~~</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote><p>gulp的功能还有很多，也十分便捷高效。此番小试牛刀，更待日后探索。。。</p><p>最后，附上Butterfly主题作者关于Gulp压缩的教程，一个 <code>gulp </code> 命令轻松完成文件压缩！</p><p><a href="https://butterfly.js.org/posts/4073eda/#Gulp%E5%A3%93%E7%B8%AE">https://butterfly.js.org/posts/4073eda/#Gulp%E5%A3%93%E7%B8%AE</a></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="https://www.jianshu.com/p/a9e7838c8043">gulp 及其常用插件</a></p><p>[2] <a href="https://www.cnblogs.com/2050/p/4198792.html">前端构建工具gulpjs的使用介绍及技巧</a></p><p>[3] <a href="https://blog.csdn.net/weixin_33929309/article/details/86069162?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">Gulp新手入门教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gulp </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建记录 Hexo+Butterfly+Github Page+Coding</title>
      <link href="posts/50074.html"/>
      <url>posts/50074.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>其实我一直有搭建博客的想法，但直到今天才开通了这个博客，还是利用上假期的闲工夫，在大佬们博文的帮助下，小站初具模样，这里对他们致以万分感谢。下面就搭建过程进行简单记录。</p><h1 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><a href="https://hexo.io/zh-cn/">Hexo</a> 是一款基于 Node.js 用于快速搭建博客的框架，有了它就可以完成完成个人博客的构建，它会帮你构建博客的整个框架，你只需要会使用Markdown 写博客即可。关于Hexo的具体介绍，可以在其官方网站查看具体的说明。</li><li><a href="https://butterfly.js.org/">Butterfly</a> 博客主题。A Simple and Card UI Design theme for Hexo.</li><li><a href="https://help.github.com/en/articles/what-is-github-pages">Github Page</a> 是 Github 提供的静态网站托管服务，可从 Github 仓库中展示你的个人、组织或者项目的静态网页。你可以选择使用 Github Pages 免费提供的域名 github.io 或者自己购买域名来发布站点，站点可以被免费托管在 Github 上。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。</li><li><a href="https://coding.net/">Codiing</a> 是一站式软件研发管理协作平台，提供 Git/SVN 代码托管、项目协同、测试管理等工具，将博客托管在coding上，可提高国内访问博客的速度。</li><li><a href="https://git-scm.com/">Git</a> 是目前世界上最先进的分布式版本控制系统（没有之一）。这里我们使用git bash 完成安装，初始化，上传等操作。</li><li><a href="https://nodejs.org/zh-cn/">node.js</a> 是一个基于Chrome V8引擎的JavaScript运行环境。安装好node.js后利用npm包管理工具来安装Hexo</li></ul><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>在windows10系统下，前往<a href="https://git-scm.com/">Git</a>官网下载，安装。其他系统下的Git安装方法可在<a href="https://hexo.io/zh-cn/docs/">hexo的文档</a>中查阅。</p><p>安装正确的话，在桌面或文件夹空白处鼠标右键菜单会新增“Git GUI Here”和“Git Bash Here”两个选项。</p><p>Git 常用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone -b &lt;branch&gt; https://github.com/xxxx/xxxx.git</span><br><span class="line">git pull</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;comment&#x27;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>前往<a href="https://nodejs.org/zh-cn/">node.js官网</a> 选择长期支持版本的node.js下载，默认路径安装即可。</p><p>在cmd中输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>出现版本信息则表示安装成功。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>完成前两个应用的安装后，即可使用npm安装Hexo</p><p>在桌面空白处单击右键，打开git bash，输入Hexo安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>因为npm是从国外服务器下载，可能出现异常，速度慢等问题，所以有更好的选择</p><p><strong><a href="https://developer.aliyun.com/mirror/NPM?from=tnpm">淘宝NPM镜像</a></strong></p><p>这是一个完整 <code>npmjs.org</code> 镜像，你可以用此代替官方版本(只读)，同步频率目前为 <strong>10分钟</strong> 一次以保证尽量与官方服务同步。</p><p>其安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>之后可以使用其定制的 <a href="https://github.com/cnpm/cnpm">cnpm</a> (gzip 压缩支持) 命令行工具代替默认的 <code>npm</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>下载速度快了不少有没有</p><p>检查Hexo是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>出现版本信息则表示安装成功。</p><p>安装好以后，可以使用以下两种方式执行 Hexo：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code></li></ol><h1 id="搭建工作"><a href="#搭建工作" class="headerlink" title="搭建工作"></a>搭建工作</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>这里在E盘下新建一个目录<code> Blog</code>,用来存放相关文件。在此处打开 <code>Git Bash</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><blockquote><p>注意：若没有把Hexo添加到环境变量，在所有命令中的 <code>hexo</code> 前都要加上 <code>npx</code></p></blockquote><p>命令执行完成后，将在E:\Blog\下生成相应的文件，目录如下：</p><p><img src="https://i.loli.net/2021/01/30/FAnR3pHMTsYbeaL.png" alt="image-20210130221733932"></p><p>主要关注的是：</p><ul><li>_config.yml , 配置文件，在此配置大部分参数</li><li>source/_posts , 存放md文件</li><li>themes , 主题文件夹</li></ul><h2 id="生成静态页面-本地"><a href="#生成静态页面-本地" class="headerlink" title="生成静态页面(本地)"></a>生成静态页面(本地)</h2><p>可通过以下命令生成静态页面:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>完成后会在根目录E:\Blog\下生成public文件夹，里面包含相应的html页面。</p><p><img src="https://i.loli.net/2021/01/30/1sKW7qJ9gkxTCfc.png" alt="image-20210130222715240"></p><h2 id="启动服务器-本地"><a href="#启动服务器-本地" class="headerlink" title="启动服务器(本地)"></a>启动服务器(本地)</h2><p>可通过以下命令启动服务器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>这条指令运行完成后可在本地启动服务器并预览博客，默认网址为<code>http://localhost:4000/</code>。<br>如果以上步骤都不出意外的话，你就会看到一个Hexo博客初始化的页面。</p><p><img src="https://i.loli.net/2021/01/30/YTqGb8ipVjBWQCv.png"></p><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>默认的主题可能并不是我们想要的效果，那么就可以通过更换主题来实现。可以在<a href="https://hexo.io/themes/">Heox官网的主题页面</a>选择想要的主题。这里，选择Butterfly主题。感谢开源此主题的各位大佬们，让我用上了这么好的页面。</p><p>Butterfly主页的展示页面：<a href="https://jerryc.me/">https://jerryc.me</a> </p><p>详细的安装文档的地址为：<a href="https://jerryc.me/posts/21cfbf15">https://jerryc.me/posts/21cfbf15</a></p><p>Github地址：<a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a></p><p>根据文档说明直接配置主题即可，这里简单记录如下：</p><blockquote><p>Butterfly主题安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly</span><br></pre></td></tr></table></figure><blockquote><p>应用主题</p></blockquote><p>修改站点配置文件<code>_config.yml</code>，把主题改为<code>butterfly</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>为方便后续设置，这里把<code>butterfly</code> 目录下的 <code>_config.yml</code> 配置文件复制到 <code>Blog</code> 目录下，并重新命名为 <code>_config.butterfly.yml</code>。以后对主题的相关设置只需要在 <code>_config.butterfly.yml</code>进行配置就行。</p><p><img src="https://i.loli.net/2021/01/30/bv2jmdBIiKNf7WF.png" alt="image-20210130122459017"></p><blockquote><p>安装相关插件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>在安装，应用主题时遇到的问题可在bufferfly的安装文档中查阅。</p><p>在一定修改后通过以下命令来查看应用主题后的初步效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  #清楚缓存文件</span><br><span class="line">hexo g  #生成发布用的静态页面</span><br><span class="line">hexo s  #重启本地服务器</span><br></pre></td></tr></table></figure><p>刷新刚才的网址：<a href="http://localhost:4000/">http://localhost:4000</a> ，可以看到更新后的主题:</p><p><img src="https://cdn.jsdelivr.net/gh/wawyw/file/hexo_butterfly_review.png"></p><p>更多细节设置，如菜单栏，背景图片，代码格式等等，可以参考Butterfly的<a href="https://jerryc.me/posts/21cfbf15">文档</a>来配置，这里不再赘述。</p><h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><blockquote><p>截止目前，已经<strong>成功安装好了一个初始化的Hexo博客</strong>。但是暂时还只能在自己电脑上看到，如何让别人通过域名可以访问到呢？接下来就要请出今天的另外一位主角<strong>GitHub Pages</strong>了。<br>另外，以上的安装步骤也可参考<a href="https://link.jianshu.com/?t=https://hexo.io/zh-cn/docs/index.html">Hexo官方文档</a>，关于各命令有更详细的解释。</p></blockquote><h2 id="创建Github仓库"><a href="#创建Github仓库" class="headerlink" title="创建Github仓库"></a>创建Github仓库</h2><p>这里假设已经注册过了Github帐户，如果没有，可以去<a href="https://github.com/">Github</a>注册。</p><p>注册好了后，登录Github,创建仓库：点击右上角的+号，选择new repository</p><p><img src="https://i.loli.net/2021/01/30/4iLYFGOtm1r3NRc.png" alt="image-20210130233629330"></p><p>将仓库名设置为 <code>username.github.io</code> ,<strong>其中,username请对应换成你的github用户名。</strong></p><p><img src="https://i.loli.net/2021/01/30/QR7uxPLNHyA1GWo.png" alt="image-20210130234029747"></p><h2 id="添加SSH公钥"><a href="#添加SSH公钥" class="headerlink" title="添加SSH公钥"></a>添加SSH公钥</h2><p>如果第一次使用git的话，需要设置用户名和邮箱:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;your username&quot;</span><br><span class="line">git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure><p>将上述的”your username”换成自己的真实用户名,”your email”换成真实的email。</p><p>然后，生成公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>在C盘/用户/用户名/.ssh目录下找到<code>id_rsa.pub</code>文件,用文本编辑工具打开，并复制所有文本内容。在Github页面右上角，点击用户头像-Settings-SSH and GPG keys-New SSH key</p><p>把复制的公钥文本内容粘贴到Key中，上方的Title可随意填写</p><p>添加完成后可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果配置成功，可以看到成功的回复。</p><h2 id="上传文件到Github仓库"><a href="#上传文件到Github仓库" class="headerlink" title="上传文件到Github仓库"></a>上传文件到Github仓库</h2><p>在配置文件<code>_config.yml</code>中添加仓库信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: #你的仓库地址,如:https://github.com/wawyw/wawyw.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>直接通过hexo来发布到github，需要安装以下插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装成功后，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d   #生成一个.deploy_git的文件夹，并把本地生成的静态文件部署Github仓库中的master分支上</span><br></pre></td></tr></table></figure><p>刷新github对应的repository页面，即可看到提交的内容：</p><p><img src="https://i.loli.net/2021/01/30/KUetpmHJ9PxB1oa.png" alt="image-20210130235436880"></p><h2 id="配置静态站点"><a href="#配置静态站点" class="headerlink" title="配置静态站点"></a>配置静态站点</h2><p>点击Settings, 进入GitHub Pages配置，由于之前新建仓库的时候，仓库名为username.github.io，github已经自己为我们发布了静态的页面。如果不是username.github.io的格式，则需要手动配置。</p><p>之后在浏览器中输入<code>username.github.io</code>（可能你已经发现了，这个就是之前新建仓库的名字，同时也是博客的域名），没毛病的话，应该可以再次看到那个熟悉又亲切的博客页面了。</p><blockquote><p>至此，我们已经通过Hexo创建了一个最原始的博客，并且通过把博客静态文件放到GitHub的仓库中，实现了从网上以GitHub的默认域名访问这个博客。</p><p>如果需要个性化域名，则需要申请对应的域名并绑定到Github上。</p><p>因为Github用的是国外的服务器，站点加载速度可能较慢，可考虑使用GitHub+coding双托管博客，这样一来，国内访问coding的服务器，国外访问GitHub的服务器，以提升国内访问博客的速度。</p></blockquote><h1 id="部署到Coding"><a href="#部署到Coding" class="headerlink" title="部署到Coding"></a>部署到Coding</h1><h2 id="创建Coding仓库"><a href="#创建Coding仓库" class="headerlink" title="创建Coding仓库"></a>创建Coding仓库</h2><p>同样，先<a href="https://coding.net/">官网注册</a></p><p>选择项目，新建一个代码托管项目<img src="https://i.loli.net/2021/02/02/kFH5Y7sBDtJd6ZO.png" alt="image-20210202114025032"></p><p>填写完项目基本信息后，完成创建</p><p><img src="https://i.loli.net/2021/02/02/Gvh47RtmBHxTCwJ.png" alt="image-20210202114214799"></p><h2 id="添加SSH公钥-1"><a href="#添加SSH公钥-1" class="headerlink" title="添加SSH公钥"></a>添加SSH公钥</h2><p>找到之前部署到Github时生成的<code>id_rsa.pub</code> 文件，复制其内容。</p><p>打开Coding的<code>个人设置</code>，<code>SSH公钥</code>，添加公钥，名称自定，粘贴刚才复制的公钥，添加好后如下图。</p><p><img src="https://i.loli.net/2021/02/02/yTJ34V9SzZxYuNr.png" alt="image-20210202114643411"></p><p><img src="https://i.loli.net/2021/02/02/czZBXJvNPqYMoiQ.png" alt="image-20210202115022080"></p><h2 id="上传文件到Coding仓库"><a href="#上传文件到Coding仓库" class="headerlink" title="上传文件到Coding仓库"></a>上传文件到Coding仓库</h2><p>打开新建的仓库，点击克隆➡模式选ssh➡复制地址，将仓库链接添加到站点的配置文件 <code>_config.yml</code> 中</p><p><img src="https://i.loli.net/2021/02/02/8RJeOF6nyjUsrbi.png" alt="image-20210202115328829"></p><p>修改完之后 <code>hexo d</code> 部署就会将 public 目录推送到 Coding 上博客仓库的 master 分支。部署后仓库如下：</p><p><img src="https://i.loli.net/2021/02/02/ExJgFdcnDqHbXyQ.png" alt="image-20210202115530532"></p><h2 id="配置静态站点-1"><a href="#配置静态站点-1" class="headerlink" title="配置静态站点"></a>配置静态站点</h2><p>把博客上传部署到仓库后，我们还要在Coding生成静态页面。</p><p>进入仓库，进入<code>项目设置</code><strong>（注意这个在左下角）</strong>，<code>项目与成员</code>，右侧<code>功能开关</code>，开启 <code>持续部署</code>即可</p><p><img src="https://i.loli.net/2021/02/02/hw39alxYncKVSiv.png" alt="image-20210202115821544"></p><p>开启后就会在仓库的左侧看到此功能，点击<code>静态网站</code>，新建网站，填写网站名称，其它默认，保存。</p><p>开启服务后会出现访问地址，如下图：</p><p><img src="https://i.loli.net/2021/02/02/sz2NhSQv1c3UPJq.png" alt="image-20210202120139692"></p><p>访问此地址后会跳转到你的博客首页。与GitHub部署类似，此网址相当于你博客的另一个访问地址。我们后面要把所有的这些网址都解析到同一个域名上。</p><h1 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h1><blockquote><p>配置好Github和Coding的静态页面后，已经可以通过给定的网址访问到博客页面了。如果需要个性化域名，则需要申请对应的域名并绑定到Github和Coding上。</p></blockquote><h2 id="注册域名"><a href="#注册域名" class="headerlink" title="注册域名"></a>注册域名</h2><p>注册域名的平台有很多可以选择，这里以阿里云为例。</p><p>来到<a href="https://wanwang.aliyun.com/domain/">万网平台</a>，查询可注册的域名</p><p><img src="https://i.loli.net/2021/02/02/1euIfLRiU6JWCr4.png" alt="image-20210202122045985"></p><p>挑选喜欢的域名，加入清单→立即结算→立即购买</p><p><img src="https://i.loli.net/2021/02/02/LjRiADB5tTsnMzV.png" alt="image-20210202122234878"></p><blockquote><p>这里选择的是<code> .top</code> 域名，你懂的😂</p></blockquote><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>登录<a href="https://homenew.console.aliyun.com/home/dashboard/ProductAndService">阿里云的控制台</a>，点击左侧菜单-域名，进入域名管理页面。</p><p>在域名列表中，找到需要解析的域名，点击对应的解析按钮。</p><p><img src="https://i.loli.net/2021/02/02/bQ8rnTtdPepaWS7.png" alt="image-20210202123116868"></p><p>点击”添加记录”</p><p><img src="https://i.loli.net/2021/02/02/8gGsqTyaJvHZpO7.png" alt="image-20210202123225340"></p><h3 id="解析-Github"><a href="#解析-Github" class="headerlink" title="@解析-Github"></a>@解析-Github</h3><p>在cmd窗口中，ping一下之前配置的Githun的静态页面地址</p><p><img src="https://i.loli.net/2021/02/02/oeJlf2GacxBF7QT.png" alt="image-20210202123556068"></p><p>可以获取到对应的ip地址</p><p>添加记录编辑如下：</p><p><img src="https://i.loli.net/2021/02/02/MDpf4OdtBhJwT18.png" alt="image-20210202124304317"></p><ul><li>记录类型选择A，添加 A 记录可实现将域名指向 IP 地址。</li><li>主机记录输入@，一般是指子域名的前缀（如需创建子域名为<a href="http://www.dns-example.com/">www.dns-example.com</a>, 主机记录输入 <strong>www</strong>；如需实现dns-example.com，主机记录输入 **@**）</li><li>解析线路选择境外,因为我们是准备国内访问时访问到Coding，国外访问时访问到Github</li><li>记录值输入刚才获取到的ip地址,如:185.199.110.153</li></ul><h3 id="www解析-Github"><a href="#www解析-Github" class="headerlink" title="www解析-Github"></a>www解析-Github</h3><p>添加记录编辑如下：</p><p><img src="https://i.loli.net/2021/02/02/GrqatcWw3FdnSmz.png" alt="image-20210202124929421"></p><ul><li>记录类型选择CNAME,添加 CNAME 记录可实现将域名指向另外一个域名。</li><li>主机记录输入www</li><li>解析线路选择境外</li><li>记录值就输入Github的静态页面地址,即 wawyw.github.io</li></ul><h3 id="解析-Coding"><a href="#解析-Coding" class="headerlink" title="@解析-Coding"></a>@解析-Coding</h3><p>在cmd窗口中，ping一下之前配置的Coding的静态页面地址</p><p><img src="https://i.loli.net/2021/02/02/yt3M4K8bj7sFSHk.png" alt="image-20210202125402543"></p><p>可以获取到对应的ip地址</p><p>添加记录编辑如下：</p><p><img src="https://i.loli.net/2021/02/02/SYh8u9rwLUNixpD.png" alt="image-20210202125550187"></p><ul><li>记录类型选择A</li><li>主机记录输入@</li><li>解析线路选择默认</li><li>记录值输入刚才获取到的ip地址,如:124.156.144.32</li></ul><h3 id="www解析-Coding"><a href="#www解析-Coding" class="headerlink" title="www解析-Coding"></a>www解析-Coding</h3><p>添加记录编辑如下：</p><p><img src="https://i.loli.net/2021/02/02/SeVBI1XAzavonUT.png" alt="image-20210202125909957"></p><ul><li>记录类型选择CNAME</li><li>主机记录输入www</li><li>解析线路选择默认</li><li>记录值就输入Coding的静态页面地址</li></ul><p>最后配置完成如下图：</p><p><img src="https://i.loli.net/2021/02/02/fYBiz2cT3FkqdEX.png" alt="image-20210202130137863"></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="Github域名绑定"><a href="#Github域名绑定" class="headerlink" title="Github域名绑定"></a>Github域名绑定</h3><p>在项目根目录-source目录下，新建CNAME文件,内容输入前面申请的域名，如:<a href="http://www.wawyw.top/">www.wawyw.top</a></p><p><img src="https://i.loli.net/2021/02/02/64joLQzHBKOqmiE.png" alt="image-20210202130504760"></p><p>上传到Github和Coding的仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>上传后就可以在Github和Coding对应的项目根目录下发到提交到的CNAME文件。</p><p>由于提交了CNAME文件，Github的静态页面服务已经自动绑定了新提交的域名</p><p><img src="https://i.loli.net/2021/02/02/8F6tvVLCE7eWqKl.png" alt="image-20210202130924470"></p><p>这时，就可以用上面自定义的域名访问我们的博客了。</p><h3 id="Coding域名绑定"><a href="#Coding域名绑定" class="headerlink" title="Coding域名绑定"></a>Coding域名绑定</h3><p>回到Coding仓库的静态网站设置页面，选择自定义域名→新建域名</p><blockquote><p><strong>注意</strong>：一定要添加两条，一条带<code>www.</code>的，一条不带<code>www.</code>的</p></blockquote><p><img src="https://i.loli.net/2021/02/02/8oD2RBig7FwLpGV.png" alt="image-20210202135629358"></p><p>添加后会给出两条CNAME记录，需要回到阿里云控制台的解析设置中修改对应的记录值</p><p><img src="https://i.loli.net/2021/02/02/2RzO14uBefParJl.png" alt="image-20210202135944688"></p><blockquote><p>OK！现在我们就算完成了GitHub+Coding双托管博客了</p><p>这样国内的用户访问的就是coding上部署的博客，而国外的用户访问的就是github上部署的博客</p></blockquote><h2 id="国内测速对比"><a href="#国内测速对比" class="headerlink" title="国内测速对比"></a>国内测速对比</h2><p>测速网站：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a></p><p><strong>国内访问GitHub服务器：</strong></p><p><img src="https://i.loli.net/2021/02/02/qeJIVuBFfsxjygP.png" alt="image-20210202170104490"></p><p><strong>国内访问Coding服务器：</strong></p><p><img src="https://i.loli.net/2021/02/02/fWmNrIyg17Ab9ih.png" alt="image-20210202171245483"></p><blockquote><p>一对比我们就可以看到Coding服务器在国内访问快多了，而GitHub服务器在国内访问有很多都是超时，速度提升较明显。</p></blockquote><p>不过，在后面体验过CDN加速后，这又算得了啥，先上图</p><p><img src="https://i.loli.net/2021/02/07/o5CnxDYNiMLIjSy.png" alt="image-20210207002805836"></p><p>这里选择了腾讯云的CDN加速服务，新用户可以白嫖6个月的流量哟。又拍云的CDN也不错，更多详情可以去官网了解。（前提要做好网站的备案工作）</p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><p>创建页面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page page_name</span><br></pre></td></tr></table></figure><p>这里在<code>source/_posts</code> 目录下以<code>markdown</code> 的格式编辑博客文章。</p><blockquote><p>Front-matter</p></blockquote><p>Front-matter 是md文件最上方以<code>---</code>分隔的区域，用于指定每篇博客的信息。</p><p>如果标注<code>可选</code>的参数，可根据自己需要添加，不用全部都写在markdown里</p><p><strong>Page Front-matter</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">type:</span><br><span class="line">description:</span><br><span class="line">comments:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">aside:</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">写法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">【必需】页面标题</td></tr><tr><td align="center">date</td><td align="center">【必需】页面创建日期</td></tr><tr><td align="center">type</td><td align="center">【必需】标签、分类等页面需要配置</td></tr><tr><td align="center">updated</td><td align="center">【可选】页面更新日期</td></tr><tr><td align="center">description</td><td align="center">【可选】页面描述</td></tr><tr><td align="center">comments</td><td align="center">【可选】显示页面评论模块(默认 true)</td></tr><tr><td align="center">top_img</td><td align="center">【可选】页面顶部图片</td></tr><tr><td align="center">aside</td><td align="center">【可选】显示侧边栏 (默认 true)</td></tr></tbody></table><p><strong>Post Front-matter</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">updated:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">sticky:</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">写法</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">【必需】文章标题</td></tr><tr><td align="center">date</td><td align="center">【必需】文章创建日期</td></tr><tr><td align="center">updated</td><td align="center">【可选】文章更新日期</td></tr><tr><td align="center">tags</td><td align="center">【可选】文章标签</td></tr><tr><td align="center">categories</td><td align="center">【可选】文章分类</td></tr><tr><td align="center">top_img</td><td align="center">【可选】文章顶部图片</td></tr><tr><td align="center">cover</td><td align="center">【可选】文章封面</td></tr><tr><td align="center">sticky</td><td align="center">【可选】文章置顶，数值越大，置顶的优先级越大。</td></tr></tbody></table><p>博客编辑完成后，仍然是通过这三步发布文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>发布之前，在本地预览博客用到的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/01/31/Vla8QmTZKeF7SLX.png" alt="image-20210131023529206"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote><p>总的来说，这次的搭建过程还算顺利，期间遇到的一些问题也通过浏览大佬的文章解决了，感谢他们的分享。网络上关于利用Hexo搭建博客的资料有很多，写这篇文章主要是为了记录此次搭建博客的过程，便于后续可能再次部署，同时也希望能帮助到有需要的朋友。完结撒花~~</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]  <a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></p><p>[2]  <a href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档</a></p><p>[3]  <a href="https://www.jianshu.com/p/ea5ac6162a96">GitPages + Hexo,从0到1搭建个人博客</a></p><p>[4] <a href="https://www.milovetingting.cn/2020/01/06/Web/Hexo+Butterfly+Github+Coding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/#Hexo-Butterfly-Github-Coding%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2">Hexo+Butterfly+Github+Coding搭建个人博客</a></p><p>[5] <a href="https://www.heson10.com/posts/54971.html">Hexo在GitHub和Coding双线部署教程</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="posts/16107.html"/>
      <url>posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="manifest.json"/>
      <url>manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"string","short_name":"Junzhou","theme_color":"#49b1f5","background_color":"#49b1f5","display":"standalone","start_url":"/","icons":[{"src":"images/pwaicons/36.png","sizes":"36x36","type":"image/png"},{"src":"images/pwaicons/48.png","sizes":"48x48","type":"image/png"},{"src":"images/pwaicons/72.png","sizes":"72x72","type":"image/png"},{"src":"images/pwaicons/96.png","sizes":"96x96","type":"image/png"},{"src":"images/pwaicons/144.png","sizes":"144x144","type":"image/png"},{"src":"images/pwaicons/192.png","sizes":"192x192","type":"image/png"},{"src":"images/pwaicons/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/02/02/Srk85XVcw6L9RoA.jpg"></p><p>很抱歉，内容暂无。。。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="link/index.html"/>
      <url>link/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="我的Blog信息"><a href="#我的Blog信息" class="headerlink" title="我的Blog信息"></a>我的Blog信息</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">wawyw</span></span><br><span class="line">  <span class="attr">link:</span> <span class="string">https://wawyw.top/</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">https://cdn.jsdelivr.net/gh/wawyw/file/avatar.png</span></span><br><span class="line">  <span class="attr">descr:</span> <span class="string">活在当下</span> <span class="string">顺势而为</span></span><br></pre></td></tr></table></figure><blockquote><p>如需要交换友链，请留言！</p></blockquote>]]></content>
      
    </entry>
    
    
  
</search>
